# bitrix-promo-test
Все сделал в одном файле, возможно не самое лучшее решение и нужно было логику вывести за пределы этого файла в некий кастомный компонет. 
Но тут главное было показать логику. Да и я не очень уж хорошо разбираюсь в битриксе.

К слову логика самого задания в некоторых местах непонятная. 
По условию если пользователь входит на страницу и нажимает получить купон в течении часа после получения до этого купона, 
то ему показывает полученный ранее купон. Но купон работает по условиям задания 3 часа, 
что тогда происходит с пользователем в промежутке с 1 до 3 часов? 

А еще есть переживания что будет с базой этих акций и купонов, если на такую страницу зайдут 100500 пользователей? 
Я бы конечно лучше создавал бы такой код в рамках пользовательской сессии а проверял его и в базу его сохранял 
при вводе, применении в корзине. Это конечно не исключает вероятности что может найдется некий ушлый клиент (бот) 
который будет сбрасывать свою сессию и роллить страницу для получения максимальной скидки 50%. Но все равно 
даже с такой вероятностью ущерба от этого меньше будет чем от нагрузки на базу и роста ее в размере. 

Идеально было бы какое то временное хранилище типа MEMORY в MySQL c триггером по его очестке или кроном. 
Возможно что-то уже есть подобное в Битриксе, к сожалению я не очень глубоко его знаю. Тогда если такой бот, клиент 
получил промокод то сохранить в это хранилище id юзера, купон, время, размер скидки. И даже если клиент сбросил сессию и заново
пытается получить новый купон, то проверить в этом хранилище и если он уже получал его ранее то выдаеть его опять ему. 
А уже при использовании в корзине добавить в базу Битрикса и запустить стандартную процедуру применения купона.

Еще как бы по юзабилити, зачем показывать клиенту при повторном посещении страницы кнопку получить скидку? 
Если клиент уже получил ее ранее и мы знаем из базы о этой скидке можно просто ее показать сразу - ваш промокод ... 
ваша скидка по данной акции ... у вас осталось ... мин что бы ее использовать 
И это же поможет избежать роллинга ботами. 

И зачем клиенту форма проверки его промокода, если мы уже знаем о нем, что он у него есть и можем ему показать его, если клиент 
вдруг покинул страницу и не скопировал, забыл купон. А чужие коды тут тоже не зачем ему проверять, надо исключить такую возможность 
клиентов.

Да еще заметил что на каждый купон так как у него уникальный случайный процент скидки пришлось создавать 
уникальное правило скидки в корзине. Тоже как бы критично, а так как сами правила еще не меют признака по которому можно группировать скидки, например акция: С 8 марта! 
А в этой группе набор скидок предустановленных пусть как в условиях от 1 до 50% - 49 шт, а уже по ним
генерировать купоны клиенту и привязывать их к уже существующему правилу применения скидки в корзине. 
Это поможет избежать создания 100500 правил скидок на каждый купон. Опять же база, размер, нагрузка, скорость ...

